#!/usr/bin/env python3
# coding=utf-8

#import glob
import os
import matplotlib.pyplot as plt
import numpy as np
import math
import csv



testNum=10
singleResSize = testNum*5*5	

def getDatas(str):
	linesSeq = open(str, 'r')	
	charsSeq = [line.rstrip('\n') for line in linesSeq]
	
	inputParams=[]
	tokens=[]
	lbls=[]
	evTimes=[]
	chronoTimes=[]

	for line in charsSeq:
		tmp=line[1:]
	#	if line[:1]=='$': #TOTAL ELAPSED
			tokens= tmp.split(',',10)
			lbls.append(str(tokens[0]))
			evTimes.append(float(tokens[1]))
			chronoTimes.append(float(tokens[2]))			
		
			if(len(tokens)>2):
				inputParams.append([int(x) for x in tokens[3:]])

	#	elif line[:1]=='#': #INPUT PARAMS
			#tokens= tmp.split(',',8)
			#if(len(tokens)>2):
			#	inputParams.append([int(x) for x in tokens[1:]])

	print("\nInput params: ",inputParams)
	print("\nEvent times: ",evTimes)
	print("\nChrono times: ",chronoTimes)


	return lbls,inputParams, evTimes, chronoTimes

	
def divideDatas(chronoTimes):
	k=0
	c=0
	ch=np.zeros((5,5))
	maxT=np.zeros((5,5))
	minT=np.zeros((5,5))
	
	for i in range(5):
      		for j in range(5):
      			minT[i][j]=chronoTimes[c]
      			c+=1
	c=0
	while k<13:
      		for i in range(5):
      			for j in range(5):
				if chronoTimes[c]<minT[i][j]:
					minT[i][j]=chronoTimes[c]
					
				if chronoTimes[c]>maxT[i][j]:
					maxT[i][j]=chronoTimes[c]
					
				ch[i][j]+=chronoTimes[c]
				c+=1
		k+=1
	return ch,minT,maxT
	
	
	
	
def getAvgBlur(chronoTimes):
	avg=0

	print("CHRONO BLUR: ",chronoTimes)
	if len(chronoTimes)==testNum:
		chronoTimes.remove(max(chronoTimes))
		chronoTimes.remove(min(chronoTimes))
		avg = sum(chronoTimes)/len(chronoTimes)
	return avg
	
	
def divideDatasInv(chrono):
	k=0
	j=0
	i=0
	
	print("CHRONO DIV DATA INV: ",chrono)
	
	
	avgT=np.zeros((5,5))
	temp=[]
	
	for c in chrono:
		
		if k<testNum:
			temp.append(c)
			k+=1
		else:
			k=0
			temp.remove(max(temp))
			temp.remove(min(temp))
			avgT[i,j]=sum(temp)/len(temp)
			
			temp=[]
			temp.append(c)
			k+=1
		
			if j<(5-1):
				j+=1
			else:
				j=0
				if i<(5-1):
					i+=1
	if len(temp)!=0:
		avgT[4,4]=sum(temp)/len(temp)
	
	return avgT
					

def getAvgTimesInv(chronoTimes):
	i=0
	j=0
	c=0
	ch=[]
	chAvg=[]
	
	for c in chronoTimes:
		if i<13:
			ch.append(c)			
			i+=1
		else:	
			ch.remove(max(ch))
			ch.remove(min(ch))
			tmp = sum(ch)/len(ch)
		
			chAvg.append(tmp)
			ch=[]
			i=0
	return chAvg


def getAvgTimes(chronoTimes,minT,maxT):
	for i in range(5):
		for j in range(5):
			chronoTimes[i][j]-=maxT[i][j]+minT[i][j]
			chronoTimes[i][j]/=(testNum-2)

	return chronoTimes
	


##########
###MAIN###
##########
def main():
	for file in os.listdir("../results/"):
	    if file.endswith(".txt"):
		print(os.path.join("../results/", file))		
	
		
		if file[0:6]=="dev_sp":# and file[4:9]!="lowpar":	
			f=os.path.join("../results/", file)
			lbls,inputs,evTimes,chronoTimes = getDatas(f)
		
			print("\nEv len: ",len(evTimes))
			print("\nchrono len: ",len(chronoTimes))					
			print("\ninputs len: ",len(inputs))
		
			chFinalAvgs=np.zeros((5,5))
			evFinalAvgs=np.zeros((5,5))

			chLowFinalAvgs=np.zeros((5,5))
			evLowFinalAvgs=np.zeros((5,5))
			
			tmpChFinalAvgs=np.zeros((5,5))
			tmpEvFinalAvgs=np.zeros((5,5))
			#for s in len(evTimes): #
			lbltmp=lbls[0]
			evAvg=[]
			chAvg=[]
			i = 0
			k = 0
			l = 0
			low = 0
			#if file[4:7]=="cos":
			for l in lbls 
				if l==lbltmp:
					evAvg.append(evTimes[i])
					chAvg.append(chronoTimes[i])
					
				else:
					lbltmp=l
					for j in range(2):
						evAvg.remove(min(evAvg))
						chAvg.remove(min(chAvg))
						
						
					tmpChFinalAvgs[k,l] = sum(chAvg[:])/len(chAvg)
					tmpEvFinalAvgs[k,l] = sum(evAvg[:])/len(evAvg)
					k+=1
					
					if(k>=5):
						l+=1
						if(l>=5):
							if(low):
								chLowFinalAvgs=tmpChFinalAvgs
								evLowFinalAvgs=tmpEvFinalAvgs
								low=0
								#if I'm here it means I can plot a speedup, since 
								#I've both high and low measures of some test
								speedUp = evLowFinalAvgs/evFinalAvgs
								writeToCSV(csvPath, label, chFinalAvgs, evFinalAvg, evLowFinalAvgs, speedUp)

								
							else:
								chFinalAvgs=tmpChFinalAvgs
								evFinalAvgs=tmpEvFinalAvgs
								low=1
								
						else:
							k=0
					
						
					
					evAvg=[]
					chAvg=[]
					evAvg.append(evTimes[i])
					chAvg.append(chronoTimes[i])
				i+=1
					
					
					
					
					
					
				
		

			elif file[4:7]=="mat":
				############
				#LOW PAR MAT
				############
				inLowMat,evLowMat,chLowMat=getDatas('../results/dev_lowpar_mat.txt')
				
								
				#EVENT AVG
				print("\nLowPar MAT EventTimes: ",evLowMat)
				print("\nLowPar Event len: ",len(evLowMat))			
				evLowMm,minLowMm,maxLowMm = divideDatas(evLowMat[0:singleResSize])
				evLowSmm,minLowSmm,maxLowSmm = divideDatas(evLowMat[singleResSize:(singleResSize*2)])
				evLowLsmm,minLowLsmm,maxLowLsmm = divideDatas(evLowMat[(singleResSize*2):(singleResSize*3)])
				
				mmLowEvAvg = getAvgTimes(evLowMm,minLowMm,maxLowMm)
				smmLowEvAvg = getAvgTimes(evLowSmm,minLowSmm,maxLowSmm)
				lsmmLowEvAvg = getAvgTimes(evLowLsmm,minLowLsmm,maxLowLsmm)
				#bbLowEvAvg = getAvgBlur(evLowMat[(singleResSize*3):])				
				
				print("\nmmLowAvg Event AVG: ", mmLowEvAvg)
				print("\nsmmLowAvg Event AVG: ",smmLowEvAvg)
				print("\nlsmmLowAvg Event AVG: ", lsmmLowEvAvg)	
				#print("\nbbLowAvg Event AVG: ", bbLowEvAvg)
						
								
				#CHRONO AVG
				print("\nLowPar MAT chronoTimes: ",chLowMat)
				print("\nLowPar chrono len: ",len(chLowMat))			
				chLowMm,minLowMm,maxLowMm=divideDatas(chLowMat[0:singleResSize])
				chLowSmm,minLowSmm,maxLowSmm=divideDatas(chLowMat[singleResSize:(singleResSize*2)])
				chLowLsmm,minLowLsmm,maxLowLsmm=divideDatas(chLowMat[(singleResSize*2):(singleResSize*3)])
					
				mmLowChAvg = getAvgTimes(chLowMm,minLowMm,maxLowMm)
				smmLowChAvg = getAvgTimes(chLowSmm,minLowSmm,maxLowSmm)
				lsmmLowChAvg = getAvgTimes(chLowLsmm,minLowLsmm,maxLowLsmm)
				#bbLowChAvg=getAvgBlur(chLowMat[(singleResSize*3):])				
				
				print("\nmmLowAvg Chrono AVG: ",mmLowChAvg)
				print("\nsmmLowAvg Chrono AVG: ",smmLowChAvg)
				print("\nlsmmLowAvg Chrono AVG: ",lsmmLowChAvg)	
				#print("\nbbLowAvg Chrono AVG: ",bbLowChAvg)	
				
			
				if file[8:-4]=="invert":				
					inv=1
					
					print("\nLEN ARRAY EventTimes : ",len(evTimes))
					#EVENT AVG AND SPEEDUP
					mmEvAvg=divideDatasInv(evTimes[0:singleResSize])
					smmEvAvg=divideDatasInv(evTimes[singleResSize:(singleResSize*2)])
					lsmmEvAvg=divideDatasInv(evTimes[(singleResSize*2):(singleResSize*3)])
					#bbEvAvg=getAvgBlur(evTimes[(singleResSize*3):])
					print("\nMM INV Avg EventTimes : ",mmEvAvg)
					print("\nSMALL MM INV Avg EventTimes : ",smmEvAvg)
					print("\nLOT SMALL MM INV Avg EventTimes : ",lsmmEvAvg)
					#print("\nBB INV Avg EventTimes : ",bbEvAvg)
				
					speedUpEvMM = mmLowEvAvg/mmEvAvg
					speedUpEvSMM = smmLowEvAvg/smmEvAvg
					speedUpEvLSMM = lsmmLowEvAvg/lsmmEvAvg
					#speedUpEvBB = bbLowEvAvg/bbEvAvg
					print("\nEvent speedUpMM: ",speedUpEvMM)
					print("\nEvent speedUpSMM: ",speedUpEvSMM)
					print("\nEvent speedUpLSMM: ",speedUpEvLSMM)		
					#print("\nEvent speedUpBB: ",speedUpEvBB)
				
										
					
					#CHRONO AVG AND SPEEDUP
					mmChAvg = divideDatasInv(chronoTimes[0:singleResSize])
					smmChAvg = divideDatasInv(chronoTimes[singleResSize:(singleResSize*2)])
					lsmmChAvg = divideDatasInv(chronoTimes[(singleResSize*2):(singleResSize*3)])
					#bbChAvg = getAvgBlur(chronoTimes[(singleResSize*3):])
					print("\nMM INV Avg chronoTimes : ",mmChAvg)
					print("\nSMALL MM INV Avg chronoTimes : ",smmChAvg)
					print("\nLOT SMALL MM INV Avg chronoTimes : ",lsmmChAvg)
					#print("\nBLUR BOX INV Avg chronoTimes : ",bbChAvg)
					
					speedUpChMM = mmLowChAvg/mmChAvg
					speedUpChSMM = smmLowChAvg/smmChAvg
					speedUpChLSMM = lsmmLowChAvg/lsmmChAvg
					#speedUpChBB = bbLowChAvg/bbChAvg
					print("\nspeedUpMM: ",speedUpChMM)
					print("\nspeedUpSMM: ",speedUpChSMM)
					print("\speedUpLSMM: ",speedUpChLSMM)
					#print("\speedUpBB: ",speedUpChBB)	
								
				else:
					inv=0
					#EVENT
					mmEvAvg,smmEvAvg,lsmmEvAvg,bbEvAvg=avgMatMeasures('Event', evTimes)

					speedUpEvMM = mmLowEvAvg/mmEvAvg
					speedUpEvSMM = smmLowEvAvg/smmEvAvg
					speedUpEvLSMM = lsmmLowEvAvg/lsmmEvAvg
					#speedUpEvBB = []
					#speedUpEvBB.append(bbLowEvAvg/bbEvAvg[0])
					#speedUpEvBB.append(bbLowEvAvg/bbEvAvg[1])
					print("\nspeedUpMM: ",speedUpEvMM)
					print("\nspeedUpSMM: ",speedUpEvSMM)
					print("\nspeedUpLSMM: ",speedUpEvLSMM)		
					#print("\nspeedUpBB: ",speedUpEvBB)
					
					
					#CHRONO						
					mmChAvg,smmChAvg,lsmmChAvg,bbChAvg=avgMatMeasures('Chrono', chronoTimes)

					speedUpChMM = mmLowChAvg/mmChAvg
					speedUpChSMM = smmLowChAvg/smmChAvg
					speedUpChLSMM = lsmmLowChAvg/lsmmChAvg
					#speedUpChBB = []
					#speedUpChBB.append(bbLowChAvg/bbChAvg[0])
					#speedUpChBB.append(bbLowChAvg/bbChAvg[1])
					print("\nspeedUpMM: ",speedUpChMM)
					print("\nspeedUpSMM: ",speedUpChSMM)
					print("\nspeedUpLSMM: ",speedUpChLSMM)		
					#print("\nspeedUpBB: ",speedUpChBB)		
						
					
				#WRITE TO CSV
				lbl1='MAT MUL'
				lbl2='SMALL MM'
				lbl3='LOT SMALL MM'
				#lbl4='BLUR BOX'					
				
				if inv==1:			
					csvPath="./output/dev_mat_inv.csv"
					lbl1+=' INV'
					lbl2+=' INV'
					lbl3+=' INV'
					
				else:
					csvPath="./output/dev_mat.csv"
				
				
				with open(csvPath,  "wb") as fcsv:
					writer = csv.writer(fcsv)

					#write event
					lbl1+=' EVENT'
					lbl2+=' EVENT'
					lbl3+=' EVENT'				    
					writeToCSV(writer,lbl1,mmLowEvAvg,mmEvAvg,speedUpEvMM)
					writeToCSV(writer,lbl2,lsmmLowEvAvg,lsmmEvAvg,speedUpEvSMM)
					writeToCSV(writer,lbl3,lsmmLowEvAvg,lsmmEvAvg,speedUpEvLSMM)
					#if inv==0:
					#	lbl4+=' EVENT'	
					#	writeToCSV(writer,lbl4,bbLowEvAvg,bbEvAvg,speedUpEvBB)
					#	writeToCSV(writer,lbl4,bbLowEvAvg,bbEvAvg,speedUpEvBB)

					#write chrono
					lbl1+=' CHRONO'
					lbl2+=' CHRONO'
					lbl3+=' CHRONO'

					writeToCSV(writer,lbl1,mmLowChAvg,mmChAvg,speedUpChMM)
					writeToCSV(writer,lbl2,lsmmLowChAvg,lsmmChAvg,speedUpChSMM)
					writeToCSV(writer,lbl3,lsmmLowChAvg,lsmmChAvg,speedUpChLSMM)
					#if inv==0:
					#	lbl4+=' CHRONO'
					#	writeToCSV(writer,lbl4,bbLowChAvg,bbChAvg,speedUpChBB)
					

					####PLOTS ON MAT####		
			
					#for i in range(0,5):	
						##event		
						#plotCompTimeGraph(speedUpEvMM[i,:], speedUpEvMM[:,i],i,file[4:7],inv,1,' Event')
						#plotCompTimeGraph(speedUpEvLSMM[i,:], speedUpEvLSMM[:,i],i,file[4:7],inv,1,' Event')
						##plotCompTimeGraph(speedUpEvBB[i,:], speedUpEvBB[:,i],i,file[4:7],inv,1,' Event')
						
						##chrono
						#plotCompTimeGraph(speedUpChMM[i,:], speedUpChMM[:,i],i,file[4:7],inv,1,' Chrono')
						#plotCompTimeGraph(speedUpChLSMM[i,:], speedUpChLSMM[:,i],i,file[4:7],inv,1,' Chrono')
						##plotCompTimeGraph(speedUpChBB[i,:], speedUpChBB[:,i],i,file[4:7],inv,1,' Chrono')
		
					#farei il grafico su comp time anche per inverted, mentre lo speed up solo per la versione normale, per adesso
					for i in range(0,5):
						##event			
						plotCompTimeGraph(mmEvAvg[i,:], mmEvAvg[:,i],i,file[4:7],inv,0,' Event')
						plotCompTimeGraph(smmEvAvg[i,:], smmEvAvg[:,i],i,file[4:7],inv,0,' Event')
						plotCompTimeGraph(lsmmEvAvg[i,:], lsmmEvAvg[:,i],i,file[4:7],inv,0,' Event')
						##plotCompTimeGraph(bbEvAvg[i,:], bbEvAvg[:,i],i,file[4:7],inv,0,' Event')
						
						##chrono
						plotCompTimeGraph(mmChAvg[i,:], mmChAvg[:,i],i,file[4:7],inv,0,' Chrono')
						plotCompTimeGraph(smmChAvg[i,:], smmChAvg[:,i],i,file[4:7],inv,0,' Chrono')
						plotCompTimeGraph(lsmmChAvg[i,:], lsmmChAvg[:,i],i,file[4:7],inv,0,' Chrono')
						##plotCompTimeGraph(bbChAvg[i,:], bbChAvg[:,i],i,file[4:7],inv,0,' Chrono')
					
					for i in range(0,5):	
						##event		
						plotSpeedup(speedUpEvMM[i,:], speedUpEvMM[:,i],i,file[4:7],inv,' Event')
						plotSpeedup(speedUpEvLSMM[i,:], speedUpEvLSMM[:,i],i,file[4:7],inv,' Event')
						##plotCompTimeGraph(speedUpEvBB[i,:], speedUpEvBB[:,i],i,file[4:7],inv,1,' Event')
						
						##chrono
						plotSpeedup(speedUpChMM[i,:], speedUpChMM[:,i],i,file[4:7],inv,' Chrono')
						plotSpeedup(speedUpChLSMM[i,:], speedUpChLSMM[:,i],i,file[4:7],inv,' Chrono')
					
					#plotSpeedup(y1, y2, num, gType, inv,lblMeasure)	
			
			
			
			
			
			
			
			
			
			
			




			
			
			
			
			
#############
#WRITE TO CSV
#############			
def writeToCSV(csvPath, label, chronoTimes, eventTimes, eventLowTimes, speedUp):

	with open(csvPath,  "wb") as fcsv:
		writer = csv.writer(fcsv)
	    
	    
	    
	    #write event
	    
		writer.writerow([label,'LOW PAR'])
		writer.writerows(eventLowTimes)

		writer.writerow([label,'AVG'])
		writer.writerows(eventTimes)

		writer.writerow([label,'SPEEDUP'])
		writer.writerows(speedUp)	

		#write chrono 
    		writer.writerow([label,'CHRONO MEASURES'])
		writer.writerows(chronoTimes)
		
	    
			
			
			
			
########################
####PLOTS ON COS####
########################
def doPlots(evTimes, evLowTimes, speedUp, xDatas, lbl):				
	#grafico su comp time anche per inverted, mentre lo speed up solo per la versione normale?
	for i in range(0,5):			
		plotCompTimeGraph(evTimes[i,:], evLowTimes[:,i], xDatasRows, i,0,0,lbl)
		plotCompTimeGraph(evTimes[:,i], evLowTimes[i,:], xDatasCols, i,0,0,lbl)

	for i in range(0,5):			
		plotSpeedup(speedUp[i,:], xDatasRows, i,0, lbl)
		plotSpeedup(speedUp[:,i], xDatasCols, i,0, lbl)
		
	#plotSpeedup(y1, y2, num, gType, inv,lblMeasure)	








				
plotId=0
figId=0
	
def plotCompTimeGraph(y1, y2, x1, lblMeasure):

	global plotId	
	global figId		

	#if gType=="mat":
	#	x1=(4,16,32,64,128) #nMat
	#	x2=(32,64,128,256,512) #dimMat			
#		lblx1="N mat"
#		lblx2="DIM mat"
#	elif gType=="cos":
#		x1=(10,50,250,1250,2500)
#		x2=(3584,7168,14336,28672,57344)
#		lblx1="M"
#		lblx2="N"
		
#	if spUp==0:
#		lbly="Comp Time (ms)" + lblMeasure
#		fname= 'comp'
#	elif spUp==1:
#		lbly="Speed Up" + lblMeasure
#		fname = 'spup'
		
	title=str(lblMeasures)
	title=title.upper()
	#if inv==1:
	#	title+="-INVERTED"
	#	fname+='_inv'

	fig=plt.figure(figId)

	ay = fig.add_subplot(111)
	ay.plot(x1, y1, '-', label = lblx1, marker='o', linestyle='-', color='black', linewidth=1)

	ay2 = ay.twiny()
	ay2.plot(x1, y2, '-r', label = lblx2, marker='o', linestyle='-', color='black', linewidth=3)	
	ay2.legend(loc="upper right")
	ay.legend(loc="lower right")
	ay.grid()
	
	ay.set_ylabel(lbly)
	ay.set_xlabel(lblx1)	
	ay2.set_xlabel(lblx2)

	
	ay2.set_xticks(np.linspace(ay2.get_xticks()[0], ay2.get_xticks()[-1], len(ay.get_xticks())))

	plt.suptitle(title,  fontsize=16,horizontalalignment='left')
	plt.tight_layout()
	#plt.show()	
	
	img_name='./plt_img/'+ gType+fname+str(plotId)
	plt.savefig(img_name)
	plotId+=1
	
	figId+=1
	plt.close(fig)
	
	
	
	
	
	
	
	
	
	
def plotSpeedup(y1, x1 num, gType, inv,lblMeasure):			

	global plotId
	global figId
	
#	if gType=="mat":
#		x1=(4,16,32,64,128) #nMat
#		x2=(32,64,128,256,512) #dimMat			
#		lblx1="N mat"
#		lblx2="DIM mat"
#	elif gType=="cos":
#		x1=(10,50,250,1250,2500)
#		x2=(3584,7168,14336,28672,57344)
#		lblx1="M"
#		lblx2="N"
		
	#if spUp==0:
	#	lbly="Comp Time (ms)" + lblMeasure
	#elif spUp==1:
	lbly="Speed Up" + lblMeasure
		
	title=str(gType)
	title=title.upper()
	if inv==1:
		title+="-INVERTED"

	plt.figure(figId)

	#ay = fig.add_subplot(111)
	plt.plot(x1, y1, '-', label = 'Speedup', marker='o', linestyle='-', color='black', linewidth=1)
	plt.plot(x1, x1, marker='.',label='Ideal speed up',color='black',linestyle='--')
	plt.xlabel(lblx1)
	plt.ylabel(lbly)
	#ay2 = ay.twiny()
	#ay2.plot(x2, y2, '-r', label = lblx2, marker='o', linestyle='-', color='black', linewidth=3)	
	plt.legend(loc="upper right")
	#ay.legend(loc="lower right")
	#ay.grid()
	
	#ay.set_ylabel(lbly)
	#ay.set_xlabel(lblx1)	
	#ay2.set_xlabel(lblx2)

	
	#ay2.set_xticks(np.linspace(ay2.get_xticks()[0], ay2.get_xticks()[-1], len(ay.get_xticks())))

	plt.suptitle(title,  fontsize=16, horizontalalignment='left')
	plt.tight_layout()
	#plt.show()	
	
	#if inv:
	#	img_name='./plt_img/'+ gType+'Inv_speedup'+lblMeasure+str(num)
	#else:
	#	img_name='./plt_img/'+ gType+'_speedup'+lblMeasure+str(num)
	img_name='./plt_img/'+ gType+'Inv_spup'+str(plotId)
	plt.savefig(img_name)
	plotId+=1
	figId+=1
	plt.close()
	
	plt.figure(figId)
	#ay = fig.add_subplot(111)
	plt.plot(x2, y2, '-', label = lblx2, marker='o', linestyle='-', color='black', linewidth=1)
	plt.plot(x2, x2, marker='.',label='Ideal speed up',color='black',linestyle='--')

	#ay2 = ay.twiny()
	#ay2.plot(x2, y2, '-r', label = lblx2, marker='o', linestyle='-', color='black', linewidth=3)	
	plt.legend(loc="upper right")
	plt.xlabel(lblx2)
	plt.ylabel(lbly)
	#ay.legend(loc="lower right")
	#ay.grid()
	
	#ay.set_ylabel(lbly)
	#ay.set_xlabel(lblx1)	
	#ay2.set_xlabel(lblx2)

	
	#ay2.set_xticks(np.linspace(ay2.get_xticks()[0], ay2.get_xticks()[-1], len(ay.get_xticks())))

	plt.suptitle(title,  fontsize=16, horizontalalignment='left')
	plt.tight_layout()
	#plt.show()
	img_name='./plt_img/'+ gType+'Inv_spup'+str(plotId)
	plt.savefig(img_name)
	plotId+=1
	
	figId+=1
	plt.close()
	
	
	
	
	
	
	
	
	
	
	
	
	
	
if __name__ == "__main__":
	main()


















#######################HOST


#!/usr/bin/env python3
# coding=utf-8

#import glob
import os
import matplotlib.pyplot as plt
import numpy as np
import math
import csv

testNum=13
singleResSize = testNum*5*5
	
def getDatas(str):
	linesSeq = open(str, 'r')	
	charsSeq = [line.rstrip('\n') for line in linesSeq]
	
	inputParams=[]
	tokens=[]
	chronoTimes=[]

	for line in charsSeq:
		tmp=line[1:]
		if line[:1]=='$': #TOTAL ELAPSED
			tokens= tmp.split(',',2)
			chronoTimes.append(float(tokens[0]))		

		elif line[:1]=='#': #INPUT PARAMS			
			tokens= tmp.split(',',8)
			if(len(tokens)>1):
				inputParams.append([int(x) for x in tokens[1:]])

	print("\nInput params: ")
	print(inputParams)
	print("\nChrono times: ")
	print(chronoTimes)

	return inputParams, chronoTimes

	
def divideDatas(chronoTimes):
	k=0
	c=0
	ch=np.zeros((5,5))
	maxT=np.zeros((5,5))
	minT=np.zeros((5,5))
	
	for i in range(5):
      		for j in range(5):
      			minT[i][j]=chronoTimes[c]
      			c+=1
	c=0
	while k<13:
      		for i in range(5):
      			for j in range(5):
				if chronoTimes[c]<minT[i][j]:
					minT[i][j]=chronoTimes[c]
					
				if chronoTimes[c]>maxT[i][j]:
					maxT[i][j]=chronoTimes[c]
					
				ch[i][j]+=chronoTimes[c]
				c+=1
		k+=1

	return ch,minT,maxT
	
def divideDatasInv(chrono):
	k=0
	j=0
	i=0	
	avgT=np.zeros((5,5))
	temp=[]
	
	for c in chrono:
		
		if k<testNum:
			#print(k)
			temp.append(c)
			k+=1

		else:
			k=0
			temp.remove(max(temp))
			temp.remove(min(temp))
			#print("i: ",i,"j: ",j)
			#print("temp: ",temp)
			avgT[i,j]=sum(temp)/len(temp)
			
			temp=[]
			temp.append(c)
			k+=1
		
			if j<(5-1):
				j+=1
			else:
				j=0
				if i<(5-1):
					i+=1
	avgT[4,4]=sum(temp)/len(temp)
	
	return avgT
	


def getAvgTimes(chronoTimes,minT,maxT):
	for i in range(5):
		for j in range(5):
			chronoTimes[i][j]-=maxT[i][j]+minT[i][j]
			chronoTimes[i][j]/=(testNum-2)
	
	return chronoTimes
	

##########
###MAIN###
##########
def main():
	for file in os.listdir("../results/"):
	    if file.endswith(".txt"):
		print(os.path.join("../results/", file))
		
		if file[0:4]=="host": 
			f=os.path.join("../results/", file)
			inputs,chronoTimes = getDatas(f)
						
			
			print("\nchrono len: ",len(chronoTimes))
			print("\ninputs len: ",len(inputs))
			
			
			



			if file[5:8]=="mat":  
			
			
			
			
			
			
				chAvg=np.zeros((5,5))
				part = len(chronoTimes)//4
		
				if file[-10:]=="invert.txt":
					inv=1
								
					chMMSeqAvg=divideDatasInv(chronoTimes[0:part])
					chMMParAvg=divideDatasInv(chronoTimes[part:(part*2)])				
					chLMMSeqAvg=divideDatasInv(chronoTimes[(part*2):(part*3)])
					chLMMParAvg=divideDatasInv(chronoTimes[(part*3):(part*4)])
				
				
					print("\nMATMUL SEQ INV Avg chronoTimes : ", chMMSeqAvg)
					print("\nMATMUL PAR INV Avg chronoTimes : ",chMMParAvg)
					print("\nLOT MATMUL SEQ INV Avg chronoTimes : ", chLMMSeqAvg)
					print("\nLOT MATMUL PAR INV Avg chronoTimes : ",chLMMParAvg)

				
				else:
					inv=0
					chMMSeq,minMMSeqT,maxMMSeqT=divideDatas(chronoTimes[0:part])
					chMMPar,minMMParT,maxMMParT=divideDatas(chronoTimes[part:(part*2)])
					chLMMSeq,minLMMSeqT,maxLMMSeqT=divideDatas(chronoTimes[(part*2):(part*3)])
					chLMMPar,minLMMParT,maxLMMParT=divideDatas(chronoTimes[(part*3):(part*4)])
					print("\nLOT MATMUL SEQ chronoTimes: ", chLMMSeq)
					print("\nLOT MATMUL PAR chronoTimes: ", chLMMPar)
					print("\nMATMUL SEQ chronoTimes: ", chMMSeq)
					print("\nMATMUL PAR chronoTimes: ", chMMPar)

					
					chMMSeqAvg = getAvgTimes(chMMSeq,minMMSeqT,maxMMSeqT)
					chMMParAvg = getAvgTimes(chMMPar,minMMParT,maxMMParT)
					chLMMSeqAvg = getAvgTimes(chLMMSeq,minLMMSeqT,maxLMMSeqT)
					chLMMParAvg = getAvgTimes(chLMMPar,minLMMParT,maxLMMParT)
					
					print("\nMATMUL SEQ Chrono AVG: ", chMMSeqAvg)
					print("\nMATMUL PAR Chrono AVG: ", chMMParAvg)
					print("\nLOT MATMUL SEQ Chrono AVG: ", chLMMSeqAvg)
					print("\nLOT MATMUL PAR Chrono AVG: ", chLMMParAvg)
					
				# sec -> millisec 
				chMMSeqAvg = chMMSeqAvg*1000
				chMMParAvg = chMMParAvg*1000
				chLMMSeqAvg = chLMMSeqAvg*1000
				chLMMParAvg = chLMMParAvg*1000
				#####SPEED UP#####
				speedUpMM=chMMSeqAvg/chMMParAvg
				speedUpLMM=chLMMSeqAvg/chLMMParAvg
				print("\nMATMUL Speedup: ", speedUpMM)
				print("\nLOT MATMUL Speedup: ", speedUpLMM)

			
			
			
			
			
			
				if inv==0:
					with open("./output/host_mat.csv",  "wb") as fcsv:
						writer = csv.writer(fcsv)
									
						writer.writerow(['MAT MUL','SEQ'])
						writer.writerows(chMMSeqAvg)
						writer.writerow(['MAT MUL','PAR'])
						writer.writerows(chMMParAvg)
						writer.writerow(['MAT MUL','SPEEDUP'])
						writer.writerows(speedUpMM)
						
						writer.writerow(['LOT MAT MUL','SEQ'])
						writer.writerows(chLMMSeqAvg)
						writer.writerow(['LOT MAT MUL','PAR'])
						writer.writerows(chLMMParAvg)
						writer.writerow(['LOT MAT MUL','SPEEDUP'])
						writer.writerows(speedUpLMM)
				else:
					with open("./output/host_mat_inv.csv",  "wb") as fcsv:
						writer = csv.writer(fcsv)
						writer.writerow(['INV MM','SEQ'])
						writer.writerows(chMMSeqAvg)
						writer.writerow(['INV MM','PAR'])
						writer.writerows3(chMMParAvg)
						writer.writerow(['INV MM','SPEEDUP'])
						writer.writerows(speedUpMM)
						
						writer = csv.writer(fcsv)
						writer.writerow(['INV LOT MM','SEQ'])
						writer.writerows(chLMMSeqAvg)
						writer.writerow(['INV LOT MM','PAR'])
						writer.writerows(chLMMParAvg)
						writer.writerow(['INV LOT MM','SPEEDUP'])
						writer.writerows(speedUpLMM)
				
				
				
				
				for i in range(0,5):			
					plotCompTimeGraph(speedUpMM[i,:], speedUpMM[:,i],i,file[5:8],inv,1)
				for i in range(0,5):			
					plotCompTimeGraph(chMMParAvg[i,:], chMMParAvg[:,i],i,file[5:8],inv,0)
					
				for i in range(0,5):			
					plotCompTimeGraph(speedUpLMM[i,:], speedUpLMM[:,i],i,file[5:8],inv,1)
				for i in range(0,5):			
					plotCompTimeGraph(chLMMParAvg[i,:], chLMMParAvg[:,i],i,file[5:8],inv,0)
			
			elif file[5:8]=="cos":
			
			
			
			
			
				chAvg=np.zeros((5,5))
				half = len(chronoTimes)//2
		
				if file[-10:]=="invert.txt":
					inv=1
								
					chSeqAvg=divideDatasInv(chronoTimes[:half])
					chParAvg=divideDatasInv(chronoTimes[half:])
				
					print("\nSEQ INV Avg chronoTimes : ", chSeqAvg)
					print("\nPAR INV Avg chronoTimes : ", chParAvg)
				
				else:
					inv=0
					chSeq,minSeqT,maxSeqT=divideDatas(chronoTimes[:half])
					chPar,minParT,maxParT=divideDatas(chronoTimes[half:])
					print("\nSEQ chronoTimes: ", chSeq)
					print("\nPAR chronoTimes: ", chPar)
					
					chSeqAvg = getAvgTimes(chSeq,minSeqT,maxSeqT)
					chParAvg = getAvgTimes(chPar,minParT,maxParT)
		
					print("\nSEQ Chrono AVG: ", chSeqAvg)
					print("\nPAR Chrono AVG: ", chParAvg)
					
				# sec -> millisec	
				chSeqAvg = chSeqAvg*1000
				chParAvg = chParAvg*1000
				#####SPEED UP#####
				speedUp=chSeqAvg/chParAvg
				print("\nSpeedup: ", speedUp)
		
			
			
			
			
			
				if inv==0:	
					with open("./output/host_cos.csv",  "wb") as fcsv:
						writer = csv.writer(fcsv)
						writer.writerow(['COS','SEQ'])
						writer.writerows(chSeqAvg)
						writer.writerow(['COS','PAR'])
						writer.writerows(chParAvg)
						writer.writerow(['COS','SPEEDUP'])
						writer.writerows(speedUp)
				else:
					with open("./output/host_cos_inv.csv",  "wb") as fcsv:
						writer = csv.writer(fcsv)
						writer.writerow(['INV COS','SEQ'])
						writer.writerows(chSeqAvg)
						writer.writerow(['INV COS','PAR'])
						writer.writerows(chParAvg)
						writer.writerow(['INV COS','SPEEDUP'])
						writer.writerows(speedUp)
			
			
			
			#plotCompTimeGraph(speedUp[0,:], speedUp[:,0],0,file[5:8],inv,1)	
				for i in range(0,5):			
					plotCompTimeGraph(speedUp[i,:], speedUp[:,i],i,file[5:8],inv,1)
			
				#farei il grafico su comp time anche per inverted, mentre lo speed up solo per la versione normale, per adesso
				for i in range(0,5):			
					plotCompTimeGraph(chParAvg[i,:], chParAvg[:,i],i,file[5:8],inv,0)
			
								
				
def plotCompTimeGraph(y1, y2, num, gType, inv, spUp):			

	if gType=="mat":
		x1=(4,16,32,64,128) #nMat
		x2=(32,64,128,256,512) #dimMat			
		lblx1="N mat"
		lblx2="DIM mat"
	elif gType=="cos":
		x1=(10,50,250,1250,2500)
		x2=(3584,7168,14336,28672,57344)
		lblx1="M"
		lblx2="N"
		
	if spUp==0:
		lbly="Comp Time (ms)"
	elif spUp==1:
		lbly="Speed Up"
		
	title=str(gType)
	title=title.upper()
	if inv==1:
		title+="-INVERTED"
	
		
	fig=plt.figure(num)

	ay = fig.add_subplot(111)
	ay.plot(x1, y1, '-', label = lblx1, linestyle='-',marker='o', color='black', linewidth=1)
	ay2 = ay.twiny()
	ay2.plot(x2, y2, '-r', label = lblx2, linestyle='-',marker='o', color='black', linewidth=3)	
	ay2.legend(loc="upper right")
	ay.legend(loc="lower right")
	ay.grid()
	
	ay.set_ylabel(lbly)
	ay.set_xlabel(lblx1)
	ay2.set_xlabel(lblx2)
	
	ay2.set_xticks(np.linspace(ay2.get_xticks()[0], ay2.get_xticks()[-1], len(ay.get_xticks())))
	
	plt.suptitle(title,  fontsize=16)
	plt.tight_layout()
	plt.show()
	
	#img_name='./plt_img/'+ gType+fname+str(plotId)
	#plt.savefig(img_name)
	#plotId+=1
	
	#figId+=1
	#plt.close(fig)


	
if __name__ == "__main__":
	main()











